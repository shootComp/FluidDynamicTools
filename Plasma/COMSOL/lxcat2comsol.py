#!/usr/bin/env python3
# %%
import argparse
import re
from bolos.process import Process as bolosProcess
from bolos import parser as bolosParser
import os
import logging
import copy
import itertools
import numpy as np
logging.basicConfig(level=logging.INFO)

# %%


class ComsolXsec:
    '''
    Class for a xsec in comsol format
    '''

    def __init__(self, formula, reacType, param, xsec, comment=''):
        self.formula = formula
        self.type = reacType
        self.param = param
        self.comment = comment
        self.xsec = np.array(xsec[:])

    def __copy__(self):
        return ComsolXsec(self.formula, self.type, self.param, self.xsec, self.comment)

    def __str__(self):
        dataStr = '\n'.join(['{:e} {:e}'.format(i[0], i[1])
                             for i in self.xsec])
        linewidth = int(len(dataStr)/self.xsec.shape[0])
        unitSettings = '1.0  1.0'
        return '\n'.join([self.type, self.formula, self.param, unitSettings, '-'*linewidth, dataStr, '-'*linewidth + '\n'])

    @classmethod
    def fromLxcat(cls, lxcat):
        '''Convert bolos processed class to my class

        Argument:
            lxcat: a bolos.process.Process class, it can be generated by lxcat => bolos.parser => bolos.Process
        '''
        RE_ion = re.compile('\^(\d?[+-](?:(?=[=\+\s])|$))')

        if lxcat.product:
            product = RE_ion.sub(r'\1', lxcat.product)
            product = re.sub('[\(\)]', '', product)
            if lxcat.kind == 'ATTACHMENT':
                formula = 'e+{:s}=>{:s}'.format(lxcat.target_name, product)
            elif lxcat.kind == 'IONIZATION':
                formula = 'e+{:s}=>2e+{:s}'.format(lxcat.target_name, product)
            else:
                formula = 'e+{:s}=>e+{:s}'.format(lxcat.target_name, product)
        else:
            formula = 'e+{:s}=>e+{:s}'.format(
                lxcat.target_name, lxcat.target_name)
            if lxcat.kind != 'EFFECTIVE':
                logging.warn(
                    "A reaction is not elastic collision but there is no product")
                logging.warn(
                    "Check the reaction with comment line: {:s}".format(lxcat.comment))

        reacType = lxcat.kind
        param = ''
        if reacType == 'EFFECTIVE' or reacType == 'ELASTIC':
            reacType = 'ELASTIC'
            param = '{:e}'.format(lxcat.mass_ratio)
        elif reacType == 'EXCITATION':
            if not lxcat.weight_ratio:
                param = '{:f} 1 0'.format(lxcat.threshold)
            else:
                param = '{:f} {:f} 1'.format(
                    lxcat.threshold, lxcat.weight_ratio)
        elif reacType == 'IONIZATION':
            param = '{:f}'.format(lxcat.threshold)
        elif reacType == 'ATTACHMENT':
            param = '0'
        else:
            logging.error("Unkown type of reaction {:s}".format(reacType))

        comment = lxcat.comment
        xsec = lxcat.data[:]
        logging.info('Processed collision {:s}'.format(formula))

        return cls(formula, reacType, param, xsec, comment)

    @classmethod
    def fromMerge(cls, cxsecs, index=0):
        """Merge ComsolXsecs together

        Keyword Arguments:
            - cxsecs -- a list of ComsolXsec classes to combine

        Return:
            - cxsec -- a ComsolXsec class
        """
        # New energy mesh
        x0 = [[j[0] for j in i.xsec] for i in cxsecs]
        x0 = sorted(set(itertools.chain.from_iterable(x0)))
        lx = len(x0)

        gxsec = [[i, 0.0] for i in x0]
        logging.info('Merged the following reactions: ')
        for cxsec in cxsecs:
            xsecT = list(map(list, zip(*cxsec.xsec)))
            newXsec = np.interp(
                x0, xsecT[0], xsecT[1], 0, xsecT[1][-1]).tolist()
            for i in range(lx):
                gxsec[i][1] += newXsec[i]
            logging.info('  - {:s}'.format(cxsec.formula))

        comment = '\n'.join([c.comment for c in cxsecs])
        comment = 'Combined:\n' + comment
        logging.info('New reaction:')
        logging.info('  - {:s}'.format(cxsecs[index].formula))

        return cls(cxsecs[index].formula, cxsecs[index].type, cxsecs[index].param, gxsec, comment)


# %% entry point
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="""Convert lxcat cross sections to COMSOL format. Example: ./lxcat2comsol.py TRINITI_ground.txt -p 0 1 3 7 -m "1,3" """)
    parser.add_argument('INPUT', help="Lxcat format cross sections")
    parser.add_argument('-m', '--merge', nargs='*', default=None,
                        help="Reactions to merge together, comma seperated strings (default: %(default)s)")
    parser.add_argument('-p', '--pick', type=int, nargs='*', default=None,
                        help="Reactions to convert (default:all)")
    ARGS = parser.parse_args()

    lxcatInput = ARGS.INPUT
    folder = os.path.dirname(ARGS.INPUT)
    xsecName = os.path.basename(ARGS.INPUT).split(os.path.extsep)[0]
    try:
        ext = os.path.basename(ARGS.INPUT).split(os.path.extsep)[1]
        comsolOutput = os.path.join(
            folder, '{:s}_COMSOL{:s}{:s}'.format(xsecName, os.path.extsep, ext))
    except:
        comsolOutput = os.path.join(folder, '{:s}_COMSOL'.format(xsecName))

    # Parse Lxcat with bolos
    with open(lxcatInput, 'r') as fp:
        lxcatFile = bolosParser.parse(fp)
    Lxcats = [bolosProcess(**i) for i in lxcatFile]
    Cxsecs = [ComsolXsec.fromLxcat(i) for i in Lxcats]

    if ARGS.pick:
        picked = ARGS.pick
    else:
        picked = [i for i in range(len(Lxcats))]

    # Merge
    removed = []
    if ARGS.merge:
        for m in ARGS.merge:
            if m:
                reacIndex = [int(i) for i in m.split(',')]
                newXsec = ComsolXsec.fromMerge([Cxsecs[j] for j in reacIndex])
                Cxsecs[reacIndex[0]] = newXsec
                picked.append(reacIndex[0])
                for i in reacIndex[1:]:
                    removed.append(i)

    picked = sorted(set(picked))
    picked = [i for i in picked if i not in removed]

    OutputCxsec = [Cxsecs[i] for i in picked]
    with open(comsolOutput, 'w') as f:
        for i in OutputCxsec:
            logging.info("Write reaction: {:s}".format(i.formula))
            f.write(str(i))
            f.write('\n')
